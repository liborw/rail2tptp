#!/usr/bin/env python
# encoding: utf-8
"""
rail2fof.py
Script to convert rail graph to first order logic formulas in TPTP format.

Input format:
    Node type                   format
    Jednoduché propojení:       uzel - vstup výstup
    Propojení s návěstidlem:    uzel | vstup výstup
    Spojka s návěstidlem:       uzel > vstup1 vstup2 výstup
    Výhybka:                    uzel < vstup výstup1 výstup2
    Vstupní uzel s návěstidlem: uzel I výstup
    Výstupní uzel:              uzel O vstup
    Comment:                    #

Created by Libor Wagner on 2011-05-18.
Copyright (c) 2011 . All rights reserved.
"""

import sys
import fileinput
import getopt
import tptp
import rail
from time import strftime

debug = False

usage_message = """[options] projet_name"""
help_message = usage_message + """

Options:
 -h --help      show this message
 -d --debug     print debug messages
 -s --static    generate static files
 
project_name is basename for files ".rail" which contain
topology in rail format, and ".fol" which contain folrmulas
for signposts configuration.

generated files with project_name. prefix:
    station.p           The segment axioms
    collision.p         The no collision conjecture and helpers
    from_XX_to_YY.p     The conjecture such as train will go through 
                        and helpers
    empty_XX_to_YY.p    The conjecture such as when train enter then 
                        the station will be empty at some point in 
                        the future

-s --static If this flag is set the generated files will contain
            all the axioms neaded, if this option si omited the 
            files wil be conected with imports.

-d --debug  If this flag is set all is printed to stdout and no
            file is writen.
"""

def write_from(file_to, filename_from):
    """Copy content of filename_from to opened file_to."""
    file_from = open(filename_from, "r")
    file_to.write(file_from.read())
    file_from.close()

class Usage(Exception):
    """Usage exception"""
    def __init__(self, msg):
        super(Usage, self).__init__()
        self.msg = msg

def write_head(outfile, filename):
    outfile.write("% File: {0}\n".format(filename))
    outfile.write("% Generated by {0}\n".format(sys.argv[0].split("/")[-1]))
    outfile.write("% Date: {0}\n\n".format(strftime("%Y-%m-%d %H:%M:%S")))

def open_file(filename, debug, mode):
    """Open file but when debug is true, return stdout"""
    if debug:
        return sys.stdout
    else:
        return open(filename, mode)
        
def close_file(f):
    if not f == sys.stdout:
        f.close()

def write_fol(outfile, fol):
    """Write fol."""
    for kind, name, formula in fol:
        outfile.write(tptp.fof(name, kind, formula) + "\n")

def expand_edge(edge, graph):
    head = graph.get_node(edge.head_id)
    tail = graph.get_node(edge.tail_id)
    return head, tail

def negate(formule):
    if formule == None:
        return None
    if formule[0] == '~':
        return formule[1:]
    else:
        return "~"+formule

def formula_onetrain(source, graph):
    edge_id = graph.get_node(source).outgoing[0]
    fols = []
    for out1 in graph.outputs:
        for out2 in graph.outputs[graph.outputs.index(out1)+1:]:
            formule = "(~t_{0}_{1}(T) | ~t_{0}_{2}(T))".format(edge_id, out1, out2)
            fols.append(formule)
    if len(fols) > 0:
        return "![T] : (" + ' & '.join(fols) + ")"
    else:
        return None

def formula_train(edge, direction, graph):
    """docstring for formula_train"""
    head, tail = expand_edge(edge, graph)
    
    if head.isKind(rail.INPUT):
        formula = tail.fol_stay('T', edge.name, direction) 
        if formula: 
            formula = formula + " => t_{0}_{1}(succ(T))".format(edge.name, direction)
    else:
        conj = []
        formula = head.fol_come('T', edge.name, direction)
        if formula: conj.append(formula)
        formula = tail.fol_stay('T', edge.name, direction)
        if formula: conj.append(formula)
        formula = "t_{0}_{1}(succ(T)) <=> (".format(edge.name, direction) + " | ".join(conj) + ")"
    if formula:
        return "![T] : (" + formula + ")"
    return None

def formula_collision(edge, graph):
    """docstring for formula_collision"""
    head, tail = expand_edge(edge, graph)
    
    conj_come = []
    conj_stay = []
    
    come = head.fol_come('T', edge.name, graph.outputs)
    stay = tail.fol_stay('T', edge.name, graph.outputs)
    
    if come and stay:
        return "![T]: (c_{0}(T) <=> ({1} & {2}))".format(edge.name, come, stay)
    else:
        return "![T]: (~c_{0}(T))".format(edge.name)

def formula_input(edge, graph):
    head, tail = expand_edge(edge, graph)

    conj_train = []
    
    stay = negate(tail.fol_stay('T', edge.name, graph.outputs))
    
    for out in graph.outputs:
        conj_train.append("~t_{0}_{1}(succ(T))".format(edge.name, out))
    
    if stay:
        left = "(" + stay + " & ~{0}(T))".format(head.name)
    else:
        left = "~{0}(T)".format(head.name)
    
    if len(conj_train) > 1:
        right = "(" + ' & '.join(conj_train) + ")"
    else:
        right = conj_train[0]
    
    return "![T] : (" + left + " => " + right + ")"

 
def gen_fol_station(graph):
    global debug
    fol = []
    
    for edge in graph.edges.values():
        if graph.get_node(edge.head_id).isKind(rail.INPUT): 
            name = "ax_input_" + edge.name
            formula = formula_input(edge, graph)
            if formula: fol.append(('axiom', name, formula))
    
    for source in graph.inputs:
        name = "ax_onetrain_" + source
        formula = formula_onetrain(source, graph)
        if formula: fol.append(('axiom', name, formula))

    for edge in graph.edges.values():
        for direction in graph.outputs:
            name = "ax_train_{0}_{1}".format(edge.name, direction)
            formula = formula_train(edge, direction, graph)
            if formula: fol.append(('axiom', name, formula))
            
    for edge in graph.edges.values():
        name = "ax_collision_" + edge.name
        formula = formula_collision(edge, graph)
        if formula: fol.append(('axiom', name, formula))
    
    for edge in graph.edges.values():
        name = "ax_train_" + edge.name
        conj = []
        for direction in graph.outputs:
            conj.append("t_{0}_{1}(T)".format(edge.name, direction))
        formula = "![T] : (t_{0}(T) <=> (".format(edge.name) + " | ".join(conj) + "))"
        if formula: fol.append(('axiom', name, formula))
    
#    for i in graph.inputs:
#        for o in graph.outputs:
#            ie = graph.get_node(i).outgoing[0]
#            formula = "![T] : (?[X] : (less(T,X) & t_{0}_{1}(X)))".format(ie, o)
#            fol.append(('axiom', 'ax_next_train_{0}_{1}'.format(ie,o), formula))
#    
    return fol

def gen_fol_collision(graph):
    fol = []
    
    conj = []
    for edge in graph.edges.values():
        if formula_collision(edge, graph):
            conj.append("~c_{0}(T)".format(edge.name))
    formula = "![T] : (nc(T) <=> (" + ' & '.join(conj) + "))"
    fol.append(('axiom', "ax_no_collision", formula))
    fol.append(('conjecture', "conj_no_collision","![T] : (nc(T) => nc(succ(T)))"))
    return fol
    

def gen_fol_pass(graph, source, sink):
    return []

def gen_fol_opened(graph, vertex):
    """For every time there is time where the vertex is opened."""
    node = graph.get_node(vertex)
    
    if node.isKind(rail.TOURNOUT):
        conj = []
        for i in graph.inputs:
            for o in graph.reachable_outputs(node.outgoing[0]):
                edge = graph.get_node(i).outgoing[0]
                conj.append("t_{0}_{1}(T)".format(edge, o))
        
        formula = "![T] : ( (" + " | ".join(conj) + ") => ?[X] : (less(T,X) & {0}(X)))".format(vertex)
        return  [("conjecture", "open_"+ vertex, formula)]
        
    else:
        return [("conjecture", "open_"+ vertex, "![T] : (?[X] : (less(T,X) & {0}(X)))".format(vertex))]

def gen_fol_closed(graph, vertex):
    """For every time there is time where the vertex is closed."""
    node = graph.get_node(vertex)
    
    if node.isKind(rail.TOURNOUT):
        conj = []
        for i in graph.inputs:
            for o in graph.reachable_outputs(node.outgoing[1]):
                edge = graph.get_node(i).outgoing[0]
                conj.append("t_{0}_{1}(T)".format(edge, o))
        
        formula = "![T] : ( (" + " | ".join(conj) + ") => ?[X] : (less(T,X) & ~{0}(X)))".format(vertex)
        return  [("conjecture", "open_"+ vertex, formula)]
        
    else:
        return [("conjecture", "close_"+ vertex, "![T] : (?[X] : (less(T,X) & ~{0}(X)))".format(vertex))]


def gen_fol_exit(graph, exit):
    node = graph.get_node(exit)
    edge = node.incoming[0]
    fol = []
    
    conj = []
    for output in graph.outputs:
        if not output == exit:
            conj.append("~t_{0}_{1}(T)".format(edge, output))
            
    if len(conj) > 0:
        formula = "![T] : (" + " & ".join(conj)+ ")"
        return [("conjecture", "never_wrong_"+edge, formula)]
    else:
        return []

def gen_fol_empty(graph, source, sink):
    fol = []
    edge_from = graph.get_node(source).outgoing[0]
    edge_to = graph.get_node(sink).incoming[0]
    
    conj = []
    for edge_id in graph.edges.keys():
        for output in graph.reachable_outputs(edge_id):
            conj.append("~t_{0}_{1}(T)".format(edge_id, output))
    
    formula = "![T] : (empty(T) <=> (" + ' & '.join(conj) + "))"        
    fol.append(('axiom', 'empty', formula))

    formula = "![T] : (t_{0}_{2}(T) => (?[X] : (less(T,X) & empty(X))))".format(edge_from, edge_to, sink)
    fol.append(('conjecture', 'empty_'+source+'_to_'+sink, formula))
    return fol

def read_fol(filename, kind, name):
    fol = []
    cnt = 1
    for line in rail.input_filter(fileinput.input(filename)):
        fol.append((kind, name+str(cnt), line))
        cnt = cnt + 1
    return fol

def main(argv=None):
    global debug
    
    if argv is None:
        argv = sys.argv
    try:
        try:
            opts, args = getopt.getopt(argv[1:], "hds", ["help", "debug", "static"])
        except getopt.error, msg:
            raise Usage(msg)

        static = False

        # option processing
        for option, value in opts:
            if option in ("-h", "--help"):
                raise Usage(help_message)
            if option in ("-d", "--debug"):
                debug = True
            if option in ("-s", "--static"):
                static = True

        if len(args) == 1:
            projet_name = args[0]
        #else:
        #    raise Usage(usage_message)

    except Usage, err:
        print >> sys.stderr, "Usage: " + sys.argv[0].split("/")[-1] + " " + str(err.msg)
        print >> sys.stderr, "\t for help use --help"
        return 2
    
    # Filenames
    in_rail = projet_name + '.rail'
    in_fol = projet_name + '.fol'
    in_order = 'order.p'
    out_station = projet_name + '.station.p'
    out_collision = projet_name + '.collision.p'
    
    # Import graph
    graph = rail.parse_graph(fileinput.input(in_rail))
    fol_station = gen_fol_station(graph)
    fol_signpost = read_fol(in_fol, 'axiom', 'ax_signpost_')
    fol_collision = gen_fol_collision(graph)
    
    
    # Station
    outfile = open_file(out_station, debug, "w")
    write_head(outfile, out_station)
    
    if static:
        outfile.write("include('{0}').\n".format(in_order))
    else:
        write_from(outfile, in_order)
        
    outfile.write('\n')
    write_fol(outfile, fol_station)
    
    outfile.write('\n')
    write_fol(outfile, fol_signpost)
    
    close_file(outfile)
    
    # Signposts
    
    
    # Collision
    outfile = open_file(out_collision, debug, "w")
    write_head(outfile, out_collision)
    
    if static:
        outfile.write("include('{0}').\n".format(in_order))
        outfile.write("include('{0}').\n".format(out_station))
    else:
        write_from(outfile, in_order)
        outfile.write('\n')
        write_fol(outfile, fol_station)
        outfile.write('\n')
        write_fol(outfile, fol_signpost)
    
    outfile.write('\n')
    write_fol(outfile, fol_collision)
    
    close_file(outfile)
    
    for node in graph.nodes.values():
        if not (node.isKind(rail.OUTPUT) or node.isKind(rail.CONNECTION)):
            filename = "{0}.open_{1}.p".format(projet_name, node.name)
            outfile = open_file(filename, debug, "w")
            write_head(outfile, filename)
            if static:
                outfile.write("include('{0}').\n".format(in_order))
                outfile.write("include('{0}').\n".format(out_station))
            else:
                write_from(outfile, in_order)
                outfile.write('\n')
                write_fol(outfile, fol_station)
                outfile.write('\n')
                write_fol(outfile, fol_signpost)
            fol_open = gen_fol_opened(graph, node.name)
            outfile.write('\n')
            write_fol(outfile, fol_open)
            close_file(outfile)

    for node in graph.nodes.values():
        if not (node.isKind(rail.OUTPUT) or node.isKind(rail.CONNECTION)):
            filename = "{0}.closed_{1}.p".format(projet_name, node.name)
            outfile = open_file(filename, debug, "w")
            write_head(outfile, filename)
            if static:
                outfile.write("include('{0}').\n".format(in_order))
                outfile.write("include('{0}').\n".format(out_station))
            else:
                write_from(outfile, in_order)
                outfile.write('\n')
                write_fol(outfile, fol_station)
                outfile.write('\n')
                write_fol(outfile, fol_signpost)
            fol_close = gen_fol_closed(graph, node.name)
            outfile.write('\n')
            write_fol(outfile, fol_close)
            close_file(outfile)
    
    for exit in graph.outputs:
        fol_exit = gen_fol_exit(graph, exit)
        if len(fol_exit) > 0: 
            filename = "{0}.nowrong_{1}.p".format(projet_name, exit)
            outfile = open_file(filename, debug, "w")
            write_head(outfile, filename)
            if static:
                outfile.write("include('{0}').\n".format(in_order))
                outfile.write("include('{0}').\n".format(out_station))
            else:
                write_from(outfile, in_order)
                outfile.write('\n')
                write_fol(outfile, fol_station)
                outfile.write('\n')
                write_fol(outfile, fol_signpost)
        
            outfile.write('\n')
            write_fol(outfile, fol_exit)
            close_file(outfile)

if __name__ == '__main__':
    sys.exit(main())
